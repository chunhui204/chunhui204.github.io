---
layout: post
title: "C++ Notes"
date: 2018-6-17
tag: C++ 
---   

* 1 const指针赋值

普通的const变量和非const变量之间可以相互赋值，但是对于指针变量，不能将const指针复制给非const指针，原来的值是const说明不希望被改动，如果赋值给非const变量那么就可以通过这个变量改变这个值，与初衷相悖。
```
	const int j[] = { 1, 2, 3 };
	int *  k = j; 	//error
```

对于字符串“*#%￥”例外，字符串是指针常量，可以直接赋值给普通变量（只是const修饰的指针变量不能，并不是指针常量不能复制给指针变量），但是通过变量赋值改变字符串的值是错误的，因为不能修改常量

```
	char * p = "abc";
	p[0] = 'c';  	//error
```

* 2 野指针

指针包括值为NULL的指针，指向有用内存的指针和野指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种：指针未初始化，这时指针的值是随机的会乱指一气；内存被释放时没有将指针设置为NULL，这是指针仍指向释放的内存块，但是这块内存已经无效了。

* 3 友元 friend

类的数据成员一般定义为私有成员，成员函数一般定义为公有的。但是，有时需要定义一些函数，这些函数不是类的一部分（注意友元函数不是类的一部分），但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该函数的友元函数。除了友元函数外，还有友元类，两者统称为友元。
友元是寄宿在某人家中的朋友，不是这个家庭的成员，可以访问家中的每一个成员。注意friend不是相互的，类A是类B的友元，但类B不是A的友元，不能访问A中的私有成员。

* 4 类型转换 

staic_cast<type_id>(expression): 将expression转换为type_id。可用于基类与派生类之间的上行转换（派生类->基类）和下行转换。可用于内置数据类型（int，double）的类型转换。缺点：在进行下行转换时不进行安全性检查。
dynamic_cast<type_id>(expression):只能用于基类与派生类之间的上行转换和下行转换。在下行转换是进行安全性检查：必须是type_id的派生类。而且基类中必须有虚函数，否则报错。

* 5 

语法解析问题：实例化对象时不能向构造函数传入临时变量（未命名变量A(), 返回值复制func()），否则会被解析为函数命名。必须传入命名过的对象名，或括双括号。
```
A a = A(B());
A a(func());	//应该成A a((func()))
```

C++路线：

STL容器的使用，主要是vector,list,map,string，结合数据结构进行学习。有兴趣的话看一下算法导论。

结合实战仔细品读effective系列。effective stl, c++, more , morden.

STL多线程方面(c++并发实战)，同理python多线程对于优化算法都是必不可少的，非常有必要了解TensorFlow c++ interface;
***************************************

![](/images/c1.jpg)

![](/images/c2.jpg)

![](/images/c3.jpg)

* 1 重载与覆盖（override）

重载关系只发生在同一作用域中，如同一个类或同一cpp文件，不会存在于继承关系的类中。因为子类在继承父类成员函数的过程中，如果子类的成员函数与父类中的同名（参数列表不用相同），那么父类的成员函数将被覆盖掉。
