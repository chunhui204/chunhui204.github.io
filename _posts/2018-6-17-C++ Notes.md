---
layout: post
title: "C++ Notes"
date: 2018-6-17
tag: C++ 
---   

* 1 const指针赋值

普通的const变量和非const变量之间可以相互赋值，但是对于指针变量，不能将const指针复制给非const指针，原来的值是const说明不希望被改动，如果赋值给非const变量那么就可以通过这个变量改变这个值，与初衷相悖。
```
	const int j[] = { 1, 2, 3 };
	int *  k = j; 	//error
```

对于字符串“*#%￥”例外，字符串是指针常量，可以直接赋值给普通变量（只是const修饰的指针变量不能，并不是指针常量不能复制给指针变量），但是通过变量赋值改变字符串的值是错误的，因为不能修改常量

```
	char * p = "abc";
	p[0] = 'c';  	//error
```

cons修饰函数返回值：避免使用时返回值进行赋值或修改。返回值可能是临时对象，对临时对象赋值是无意义的；可能返回值是对象引用，修改返回值会修改对象。
```
A func(){  return A(args);}
func() = 13; //编译器不能检查出来对临时对象的修改
const char & operator[](int) const;//const修饰this，表示const string对象会调用这个函数，如果返回值不加const修饰，就会通过改变返回值修改对象。
const string s;
s[0]='a'; //如果不用const返回值，这操作就是
```

* 2 野指针

指针包括值为NULL的指针，指向有用内存的指针和野指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。野指针的成因主要有两种：指针未初始化，这时指针的值是随机的会乱指一气；内存被释放时没有将指针设置为NULL，这是指针仍指向释放的内存块，但是这块内存已经无效了。

* 3 友元 friend

类的数据成员一般定义为私有成员，成员函数一般定义为公有的。但是，有时需要定义一些函数，这些函数不是类的一部分（注意友元函数不是类的一部分），但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该函数的友元函数。除了友元函数外，还有友元类，两者统称为友元。
友元是寄宿在某人家中的朋友，不是这个家庭的成员，可以访问家中的每一个成员。注意friend不是相互的，类A是类B的友元，但类B不是A的友元，不能访问A中的私有成员。

* 4 类型转换 

staic_cast<type_id>(expression):运行期间检查参数。

只适用于指针或引用类型：
	const_cast： 将const指针转化为非const指针。
	dynamic_cast： 用于多态类型之间的转换，向下转换，基类到派生类。存在继承关系的指针或引用，类中含有虚函数。
	reinterpret_cast：编译期间不进行参数检查，只在运行时才检查。用于使用之明确知道转换前后类型的正确性，一般用于内建数据类型的指针类型转换				(char*->double*), long型与地址转换，函数指针转换。
* 5 

语法解析问题：实例化对象时不能向构造函数传入临时变量（未命名变量A(), 返回值复制func()），否则会被解析为函数命名。必须传入命名过的对象名，或括双括号。
```
A a = A(B());
A a(func());	//应该成A a((func()))
```

C++路线：

STL容器的使用，主要是vector,list,map,string，结合数据结构进行学习。有兴趣的话看一下算法导论。

结合实战仔细品读effective系列。effective stl, c++, more , morden.

STL多线程方面(c++并发实战)，同理python多线程对于优化算法都是必不可少的，非常有必要了解TensorFlow c++ interface;
***************************************

![](/images/c1.jpg)

![](/images/c2.jpg)

![](/images/c3.jpg)

* 1 重载与覆盖（override）

重载关系只发生在同一作用域中，如同一个类或同一cpp文件，不会存在于继承关系的类中。
子类在继承父类成员函数的过程中，如果子类的成员函数与父类中的同名（参数列表不用相同），那么父类的成员函数将被隐藏，这叫做覆盖。
override关键字则更为严格，如果使用了override，则要求覆盖的函数名及参数列表，返回值要和基类完全相同。override一般用于定义虚函数的覆盖函数时，用来保证继承关系的虚函数格式完全一致。

* 2 继承内容
```
class Sub : public Base{};
Sub s;
```
C++有三种类型：对象类型，引用类型，指针类型。只有在生成对象类型变量的时候才会分配内存，调用构造函数，其他两个都不会。
当子类构造函数被调用时，如果没有显示指定父类构造函数，那么将调用父类的默认构造。同理子类析构函数执行完后会自动调用父类析构函数。
具有继承关系的类析构函数都要声明称虚函数，当父类引用使用子类对象时（多态）能在对象销毁时调用到子类和父类的析构函数。

子类从父类继承非私有的成员变量，子类可以直接调用；但是对于父类成员函数子类只能通过s.Base::func()的方式调用。同理在定义子类成员函数时如果想调用父类的成员函数可以直接Base::func()相当于this->Base::func();

* 3 动态调用（多态性）

存在继承关系的对象要区分对象的静态类型和动态类型，既不是引用也不是指针类型时，对象的静态类型和动态类型一致。当对象为指针（引用）类型时其静态类型是定义的类型，动态类型是实际指向对象的类型。当对象调用方法时如果调用的是静态编译的方法就是用静态类型中定义的方法，如果调用动态编译的方法（虚函数）则使用动态类型中定义的方法。
```
Base &b = Sub();  //如果b调用虚函数的话使用Sub中定义的，如果调用普通函数则调用Base中的
```
注意虚函数中的默认参数，就是有默认值的参数，在调用动态类型的虚函数时会使用静态类型虚函数的默认参数。
为了保证子类定义的虚函数与父类签名一致，一般用override，如果不一致编译器报错。

* 4 智能指针shared_ptr

对有内存泄露风险的对象指定为shared_ptr类型，有内存泄露风险是指new出的对象，可能delete操作之间会出现异常导致这块内存不能释放从而泄露；可能new操作存在于某个类的构造函数中，而delete在其析构函数中，如果这个类构造函数出现异常，就不会调用析构函数从而引起泄露。
```
class A
{
	A()
	{
		b = new B();
		something();//异常
	};
	~A(){delete b;}//由于构造函数发生异常，A的对象不会创建引而不会调用析构函数。这样b内存不会析构而泄露。
```
按理说应该对所有的new出的对象使用shared_ptr类型，保证shared_ptr对象销毁时所指向的对象也能销毁。
shared_ptr是引用计数机制，当有新的shared_ptr指向原对象计数就会加一，当shared_ptr销毁或指向其他对象，计数减一，当计数为0的时候对象就会销毁。可用于共享内存的容器定义。
```
shared_ptr<A> p = new A();
p = q;//计数减一
```
* 5.具有二义性的语法， 这些语法在有些编译器下可能解析不正确

（1）对象初始化
```
A a(arg); //arg必须是命名变量，不能使临时变量，如函数返回值，这样容易被解析为函数定义。 A a(get_func());
```
（2）从属类型，就是从属于某个命名空间下的数据类型，如namespace::T。对于从属类型要用typename修饰否则会解析成namespace下的静态成员。
```
template<typename T> //容器T
typename T::iterator begin;
typename T::iterator end;
```

（3）重载函数二义性

当实参类型可以隐式转换为不同的形参类型时，编译器不知道该调用那个重载函数，引起混乱。
```
//避免int或long和指针类型的的形参函数一起重载.因为一个整形数字即可以认为是一个地址也可以认为是一个数。
void f(int); void f(string*); 
//当实参可以通过隐式类型转换为不同的形参时也会引起二义性。
void f(int);
void f(A); //存在构造函数A(int){};
//这是应该通过显性转换指定形参类型，f(static_cast<int>(i)); or f(static_cast<A>(i));
```
* 6.运算符重载最好定义为非成员函数，配合隐式类型转换使表达式在多种参数下合法。对于类A的乘法运算来说，可能会出现以下表达式
```
class A
{
A()=default;
A(int i); 
}
A a, b;
a*b; // 这种情况成员函数可以处理
a*2; //在调用operator*，将参数2隐式转换成A类型。但是编译器不能对左边的对象隐式转换，所以下面的表达式不编译错误。
2*a; 
/**如果定义operator*(const A& lhs, const A &rhs);那么运算符两边都是参数都可以通过隐式类型转换完成表达式*/
```
* 7. 静态初始化和动态初始化

静态初始化包括零值初始化和常数值初始化，是在编译期间完成的。如int i=10;虽然这是并没有分配内存。

动态初始化是在运行期间进行的，就是只有程序运行时才知道值是多少，这时候分配内存后在初始化。int i = getint(); //比如函数调用

对于全局变量和静态全局变量来说，他们的初始化是编译时确定的，如果给定值就按当前值初始化，如果没给定就零值初始化。但是对于class类型的全局变量来说由于对象初始化要调用构造函数，所以是运行时初始化的（调用了函数）。局部变量定义在函数内部，在运行期间才分配内存，当然在定义时没有给定值是不会零值初始化的。

静态变量的初始化取决于是全局变量还是局部变量，如果是全局变量或者是类成员那么就是编译期间就确定值（因为必须在类外定义为全局变量），如果是局部变量，那就在运行期间初始化。对于全局的class类型初始化虽然是在运行时才进行的，但是也是在main函数执行之前。因为所有全局变量（cpp文件中定义的变量和class对象）都在main函数之前执行。

对象初始化的过程：首先对成员变量分配内存并初始化，内建类型零值初始化，如果成员是class类型则递归执行初始化过程。初始化列表实际上是对成员变量指定了初始化方法，所以初始化列表中的顺序并不影响成员初始化顺序。最后调用构造函数体内的代码，这是对成员变量赋值而不是初始化了。

* const与constexpr区别

const变量表示这个变量为只读，初始化后不可修改，但是初始化可以是在编译期间也可以是在运行期间。
constexpr是常量表达式，是在编译期间就确定的，比如字面值类型和编译器初始化的const变量。
```
//运行期间 const int i = getint(); 
int size = 10;
const int i = size;//虽然size在编译期间就确定了值，但是对于i来说仍是用变量赋的值只有等到运行期间才能确定，所以不是常量表达式。
```
