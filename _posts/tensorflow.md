1.

第一个括号里面的每一项是第一维的元素，再进一层括号中的项是第二维的元素，最后一维的元素是最后一层括号中单个的数字。后面的维度作为前面维度的项，
当前面维度的元素修改或复制后，后面维度的元素也是跟着变得。

2. broadcast

当两张量的秩相匹配其他维度相同，只有一个维度不同而且其中一个张量维度为1时，那么相应张量会在1这个维度上tile；
当张量比另一个张量秩少时，会以已经存在的维度为最后一个维度，然后缺失的维度补1，继续按上面的规则执行。如(2,1)和（2,）==>(2,1),(1,2) ==>(2,2),(2,2)

3. control dependency

如果你的计算图中只包含Tensor（中间量），那么不用担心控制依赖问题，在计算tensor的时候库会为我们决定出一组依赖关系的op。如果我们进行的操作中含有变量，由于变量
可以由很多运算更新，我们要得到的操作希望在变量更新后进行，但是变量更新运算和我们定义的运算是不具有控制依赖关系的，如果不强制他们之间的运行顺序，在运行定义运算的时候是不会
运行更新运算的。

```
with tf.control_dependencies([b,c]):
    assign = tf.assign(a, 5)
```
定义b,c运算一定在assign之前执行，上下文中的运算assign一定要在上下文中定义，如果是外面定义的运算只把tensor拿过来是没有效果的，注意operator=等操作都不是
节点运算，可以通过tf.identify(tensor)将tensor转为op。
